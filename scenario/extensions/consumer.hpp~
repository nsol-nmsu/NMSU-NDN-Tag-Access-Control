/**
* @class ndntac::Consumer
* @brief Consumer application with NDNTAC support
*
* This application simulates a data consumer, upon
* initialization it'll select a content to retrieve
* from the list of available contents given in the 
* config file.  The content will be selected with
* a discrete random variable with the content
* probability of each content provided in the config.
* Once all data for the content has been retrieved
* ( i.e the consumer receives an EoC packet ) the
* consumer will wait some amount of time ( determined
* by a configurable exponential random variable ) then
* select another content via the same mechanism.
*
* The consumer requests content via a dynamic window,
* the window size will grow by one slot with every
* successful retrieval, and will shrink back down to
* its base size whenever a timeout occurs.  For every
* content the consumer will request segments in increasing
* order until it receives an EoC. For every segment
* the consumer will ensure that its auth tag, if it has one,
* is valid.  If the consumer doesn't have an auth tag,
* or the auth tag is expired or doesn't match the current
* content then the consumer will request the appropriate
* auth instead of the next segment. 
*
* @author Ray Stubbs [stubbs.ray@gmail.com]
**/
#include "ns3/core-module.h"
#include "ns3/ndnSIM/apps/ndn-app.hpp"
#include "ns3/ndnSIM/NFD/daemon/fw/tx-queue.hpp"
#include "ns3/ndnSIM/model/ndn-common.hpp"
#include "ns3/ndnSIM/utils/ndn-rtt-estimator.hpp"
#include "ndn-cxx/name.hpp"
#include "ndn-cxx/interest.hpp"
#include "ndn-cxx/data.hpp"
#include "ndn-cxx/auth-tag.hpp"
#include "ndn-cxx/encoding/tlv.hpp"
#include "auth-cache.hpp"
#include "unqlite.hpp"
#include <memory>


#ifndef CONSUMER__INCLUDED
#define CONSUMER__INCLUDED

namespace ndntac
{
class Consumer : public ns3::ndn::App
{
public:
    static ns3::TypeId
    GetTypeId();

    // path to config file
    static std::string s_config;
        
    // constructor
    Consumer( void );

    // represents consumer configuration
    struct Config
    {
        // load config from file, param is consumer id
        Config( const std::string& file, uint32_t id );
        
        // allows config to specify a simulation time
        // at which the consumer should start its business
        ns3::Time start_time;

        // the lifetime of interests generated by this
        // consumer
        ns3::Time interest_lifetime;

        // frequency to check retx timeouts
        ns3::Time retx_timer;

        // initial window size
        uint32_t initial_window_size;

        // max window size, after this is reached
        // the window won't grow anymore
        uint32_t max_window_size;

        // exponential config, these configure the exponential
        // distribution that'll be used to select the interval
        // between content retrievals
        double exp_mean;
        double exp_bound;
        
        // these can be enabled to enable malicious
        // or exceptional behaviour
        bool enable_no_auth;    // don't attach auth tag to interests
        bool enable_bad_auth_sig; // bad auth tag signature
        bool enable_expired_auth; // expired auth tag
        bool enable_bad_route;    // bad route hash in auth tag
        bool enable_bad_prefix;   // bad auth prefix
        bool enable_bad_keyloc;   // bad auth key locator

        // available content
        struct Content
        {
            ndn::Name name;
            size_t size;
            double prob;
        };
        std::vector< Content > contents;
    };

private:
    
    // start
    void
    StartApplication( void ) override;
    
    // stop
    void
    StopApplication( void ) override;
    
    // called when we recieve a data packet
    void
    OnData( std::shared_ptr< const ndn::Data > data ) override;
    
    // called when the requested data is received
    void
    OnRequestSatisfied( uint32_t seq );
    
    // called when the requested data was nacked
    void
    OnRequestDenied( uint32_t seq );
    
    // called when an auth data is received
    void
    OnReceiveAuth( std::shared_ptr< const ndn::Data > data );
    
    
    // called when a timeout occurs
    void
    OnTimeout( uint32_t seq );
    
    // called to choose the next content to retrieve
    const Config::Content&
    NextContent( void );
    
    // called to choose a durration to wait before
    // starting on the next content
    ns3::Time
    NextGap( void );
    
    // called to fill the window with interests
    void
    FillWindow( void );
    
    // called to send the next interest
    void
    SendNext( void );

    // start next content
    void
    StartNextContent( void );
    
    // retransmit a request
    void
    RetX( uint32_t seq );
    
    // called periodically to check for timeouts
    void
    CheckTimeouts( void );
    
    // start the retransmission timer cycle
    void
    StartRetXTimer( void );
    
    // test if we have valid authentication
    bool
    HasAuth( void );
    

private:
    // consumer instance
    uint32_t m_instance_id;

    // config instance
    Config m_config;
    
    // name of current content
    Config::Content m_current_content;
    size_t m_content_retrieved;
    
    // maps the names of pending contents to sequence numbers
    std::map< ndn::Name, uint32_t > m_seqs;
    
    // maps sequence numbers to pending interests
    // and their properties
    struct PendingEntry
    {
        // interest
        std::shared_ptr< ndn::Interest > interest;
        
        // time of first transmission
        ns3::Time fx_time;
        
        // time of last retransmission
        ns3::Time lx_time;
        
        // retransmission timeout
        ns3::Time retx_timeout;
        
        // did the request have valid authentication
        bool valid_auth;
    };
    std::map< uint32_t, PendingEntry > m_pending;
    
    // pending retx timer event
    ns3::EventId m_retx_event;
    
    // retx queue
    std::queue< uint32_t > m_retx_queue;
    
    // next sequence number
    uint32_t m_seqno;
    
    // next segment number
    uint32_t m_segno;
    
    // current auth tag
    std::unique_ptr< ndn::AuthTag > m_auth;
    
    // retransmit timeout estimator
    ns3::Ptr< ns3::ndn::RttEstimator > m_rtt;
    
    // transmission queue
    TxQueue m_tx_queue;
    
    // current size of window
    uint32_t m_window;
    
    // flag indicating that we're waiting for an auth tag
    // keeps from making requests until auth is received
    bool m_pending_auth;
    
    // uniform RNG for use in nonce generation
    // and content selection
    ns3::Ptr< ns3::UniformRandomVariable > m_urng;
    
    // exponential random variable to use for
    // gap selection
    ns3::Ptr< ns3::ExponentialRandomVariable > m_erng;
    
    // instance tracker
    static uint32_t s_instance_id;
};

};

#endif // CONSUMER__INCLUDED
